---
layout: post
title:  "数据库知识点整理"
date:   2019-09-21 12:49:34
categories: 计算机基础
tags: 面试 数据库 
excerpt: 数据库内容整理
mathjax: true
---

## 1 存储引擎

### 1.1 概念
数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、
更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同
的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引
擎。存储引擎主要有： 1. MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5. Federated 。

### 1.2 InnoDB（B+树）
InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page，page大小是固定的，
一般设为16k。其中非叶子节点只有键值，叶子节点包含完成数据。 

适用场景： 
1. 经常更新的表，适合处理多重并发的更新请求。 
2. 支持事务。 
3. 可以从灾难中恢复（通过bin-log日志等）。 
4. 外键约束。只有他支持外键。 
5. 支持自动增加列属性auto_increment。 

### 1.3 TokuDB（Fractal Tree-节点带数据） 
TokuDB 底层存储结构为Fractal Tree,Fractal Tree的结构与B+树有些类似, 在Fractal Tree
中，每一个child指针除了需要指向一个child节点外，还会带有一个Message Buffer ，这个
Message Buffer 是一个FIFO的队列，用来缓存更新操作。 

例如，一次插入操作只需要落在某节点的Message Buffer就可以马上返回了，并不需要搜索到叶
子节点。这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。 

TokuDB在线添加索引，不影响读写操作, 非常快的写入性能， Fractal-tree在事务实现上有优
势。 他主要适用于访问频率不高的数据或历史数据归档。 

### 1.4 MyIASM
MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，
因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。 

ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织
成有固定长度的记录，按顺序存储的。---ISAM是一种静态索引结构。 

缺点是它不 支持事务处理。 

### 1.5 Memory
Memory（也叫HEAP）堆内存：使用存在内存中的内容来创建表。每个MEMORY表只实际对应
一个磁盘文件。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用
HASH索引。但是一旦服务关闭，表中的数据就会丢失掉。  Memory同时支持散列索引和B树索
引，B树索引可以使用部分查询和通配查询，也可以使用<,>和>=等操作符方便数据挖掘，散列索
引相等的比较快但是对于范围的比较慢很多。 

## 2 索引
索引（Index）是帮助 MySQL 高效获取数据的数据结构。常见的查询算法,顺序查找,二分查找,二
叉排序树查找,哈希散列法,分块查找,平衡多路搜索树B树（B-tree） 

### 2.1 常见的索引原则
1. 选择唯一性索引：唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。 
2. 为经常需要排序、分组和联合操作的字段建立索引
3. 为常作为查询条件的字段建立索引
4. 限制索引的数目：越多的索引，会使更新表变得很浪费时间。 
5. 尽量使用数据量少的索引：如果索引的值很长，那么查询的速度会受到影响。 
6. 尽量使用前缀来索引：如果索引字段的值很长，好使用值的前来索引。  
7. 删除不再使用或很少访问的索引
8. 最左前缀匹配原则：非常重要的原则
9. 尽量使用区分度高的字段作为索引：区分度的公式是表示字段不重复的比例 
10. 索引列不能参与计算，尽量保持列“干净”：带函数的查询不参与索引
11. 尽量地扩展索引，不要建立索引

## 3 数据库三范式

### 3.1 一范式(1st NF--列都是不可再分) 
第一范式的目标是确保每列的原子性:如果每列都是不可再分的小数据单元（也称为小的原子
单元），则满足第一范式（1NF）

### 3.2 二范式(2nd NF--每个表只描述一件事情) 
首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一
件事情。 

### 3.3 三范式(3rd NF--不存在对非主键列的传递依赖)
第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编
号外，顾客姓名依赖于非主键顾客编号。  

## 4 数据库事务
事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向
系统提交，要么都执行、要么都不执行 。事务是一个不可分割的工作逻辑单元。

事务必须具备以下四个属性，简称ACID 属性：

* 原子性：事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执
行。
* 一致性：当事务完成时，数据必须处于一致状态。 
* 隔离性：对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方
式依赖于或影响其他事务。
* 永久性：事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。 

## 5 存储过程
一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次
编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过
程是数据库中的一个重要对象。   

### 存储过程优化思路：
1. 尽量利用一些sql语句来替代一些小循环，例如聚合函数，求平均函数等。 
2. 中间结果存放于临时表，加索引。 
3. 少使用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如
对一个 100 万行的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次 读取。 
4. 事务越短越好。sqlserver 支持并发操作。如果事务过多过长，或者隔离级别过高，都会造成
并发操作的阻塞，死锁。导致查询极慢，cpu占用率极地。 
5. 使用try-catch处理错误异常。 
6. 查找语句尽量不要放在循环内。

## 6 触发器（一段能自动执行的存储过程）
触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是：
触发器是当对某一个表进行操作时触发。诸如：update、insert、delete 这些操作的时候，系统
会自动调用执行该表上对应的触发器。SQL Server 2005 中触发器可以分为两类：DML 触发器和
DDL 触发器，其中 DDL 触发器它们会影响多种数据定义语言语句而激发，这些语句有
create、 alter、drop语句。 

## 7 数据库并发策略
并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。 
### 乐观锁
乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自
己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间
戳就是不加锁，通过时间戳来控制并发出现的问题。 
### 悲观锁
悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加
锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数
据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允
许其他用户访问那部分数据。 
### 时间戳
时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字
段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数
据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁
机制，但是这种方法可以大大提高数据库处理的并发量， 

以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁（写锁）和共享锁（读锁）。

## 8 数据库锁
 
### 8.1 行级锁
行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle会自动应用行级锁：
1. INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT]; 
2. SELECT … FOR UPDATE语句允许用户一次锁定多条记录进行更新 
3. 使用COMMIT或ROLLBACK语句释放锁。 

### 8.2 表级锁
表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。常使
用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁
（排他锁）。 

### 8.3 页级锁
页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级
冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。

## 9 基于redis分布式锁
1. 获取锁的时候，使用setnx（SETNX key val：当且仅当key不存在时，set一个key 为 val
的字符串，返回 1；若 key 存在，则什么都不做，返回 0）加锁，锁的 value 值为一个随机生成的
UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添 加一个超时时间，超过该时间则自动释放锁。 
2. 获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取 锁。 
还设置一个获取的超时时间，若超过这个时间则放弃获取锁。 
3. 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。 

## 10 分区分表
分库分表有垂直切分和水平切分两种。

* 垂直切分(按照功能模块分)：
将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立定义数据库
workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目
数据定义表、商品定义表、用户数据表、日志数据表等。
* 水平切分（按照规则划分存储）：
当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行划
分，然后存储到多个结构相同的表，和不同的库上。

## 11 两段提交协议
分布式事务是指会涉及到操作多个数据库的事务,在分布式系统中，各个节点之间在物理上相互独立，
通过网络进行沟通和协调。
   
