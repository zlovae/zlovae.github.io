---
layout: post
title:  "JVM类加载"
date:   2019-07-07 16:37:33
categories: Java
tags: Java JVM 笔记
excerpt: JVM类加载
mathjax: true
---

读《深入理解Java虚拟机第7章》

Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用。
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，
最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载（程序运行期间）机制。

## 1.类加载的时机
类的生命周期：加载、连接（验证、准备、解析）、初始化、使用、卸载

解析（运行时绑定）

加载的时机可以由JVM自由把我，但是 **（有且仅有）** 5种情况必须立即“初始化”：
* 遇到new、getstatic、putstatic、invokeStatic、这4条字节码指令时，且类没有进行过初始化。
（使用new实例化对象的时候，读取或设置一个类的静态字段（被final修饰，已经在编译期把结果放入常量池的静态字段除外）
的时候，以及调用一个类的静态方法的时候。）
* 使用java.lang.reflect包的方法对类进行反射调用的时候，类没有初始化
* 初始化一个类时，其父类还没有初始化，先初始化其父类
* 虚拟机启动时，用户需指定一个要执行的主类（包含main()方法的那个类）
* 使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、
REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，
则需要先触发其初始化。

## 2.类加载过程

### 2.1 加载
* 通过一个类的全限定名来获取定义此类的二进制字节流
* 将这个字节流所代表的静态存储结构转化为 **方法区** 的运行时数据结构
* 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

开发人员可以重写loadClass()方法，定义自己的类加载器。

### 2.2 验证
保证Class文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机的安全。
* 文件格式验证
* 元数据验证
* 字节码验证 （最复杂的一个阶段，通过数据流和控制流的分析，确定程序语义是合法的、符合逻辑的）
* 符号引用验证 （虚拟机将符号引用转化为直接引用）

如果能够确保代码是安全的，也可以使用 -Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载时间。

### 2.3 准备
准备阶段是正式为类变量分配内存并设置 **类变量（static修饰）** 初始值的阶段。

基本数据类型的零值：
1. int 0
2. long 0L
3. short (short)0
4. char '\u0000'
5. byte (byte)0
6. boolean false
7. float 0.0f
8. double 0.0d
9. reference null

### 2.4 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
* 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义地定位到目标即可。
* 直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。

#### 需要进行解析的7类符号
* 类或接口
* 字段
* 类方法
* 接口方法

* 方法类型
* 方法句柄
* 调用点

### 2.5 初始化

## 3.类加载器

## 总结
