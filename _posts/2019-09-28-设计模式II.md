---
layout: post
title:  "设计模式II"
date:   2019-09-28 16:34:32
categories: 设计模式
tags: 面试 设计模式 
excerpt: 创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new()直接实例化对象。这使得程序在判断针对某个给定实例需要创建
哪些对象时更加灵活。
mathjax: true
---

## 创建型模式
提供一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new()直接实例化对象。这种程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
1. 工厂模式
2. 抽象工厂模式
3. 单例模式
4. 建造者模式
5. 原型模式

## 1工厂模式
工厂模式（Factory Pattern）时Java最常用的设计模式之一。工厂模式对用户隐藏对象的创建逻辑，使用者通过访问一个接口来创建新的对象。当需要在
不同条件下使用不同的实现类时，就可以用工厂模式。

### 工厂模式の使用场景
1. 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
2. 数据库访问：当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。
3. 设计一个连接远程服务器的框架，需要三个协议，"POP3"，"IMAP"，"HTTP"，可以把这三个作为产品类，共同实现一个接口。

### 步骤
1. 创建接口
2. 创建接口的实现类（有几种产品就几个实现类）
3. 创建一个工厂，生成基于给定信息的实体类的对象
4. 使用该工厂，通过传递类型信息来获取相应实体类的对象

### 工厂模式优点
1. 一个调用者想创建一个对象，只要知道其名称就可以了。
2. 扩展性高：如果想要增加一个产品，只要增加一个产品类即可。
3. 屏蔽产品的具体实现，调用者只需要关心产品的调用接口。

### 工厂模式的缺点
1. 每次增加一个产品时，都需要增加一个具体类的对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统复杂度，同时也**增加了系统对具
体类的依赖**。

## 2抽象工厂模式
在抽象工厂模式（Abstract Factory Pattern）中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式
提供对象。

### 抽象工厂模式的使用场景
1. QQ换皮肤，一整套一起换
2. 生成不同操作系统的程序。

### 抽象工厂模式的实现
1. 创建抽象工厂类AbstractFactory类
2. 定义工厂类，扩展抽象工厂类
3. 创建工厂创造器类
4. 工厂和产品类同工厂模式

### 抽象工厂模式的优点
当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用一个产品族中的对象。

### 抽象工厂模式的缺点
产品族扩展困难，要增加一个系列的某一个产品，既要在抽象的Creator里加代码，又要在具体实现类里加代码。（产品族难扩展，产品等级易扩展）

## 3单例模式（最常考）
单例模式（Singleton Pattern）是Java中最简单的设计模式之一。单例模式只涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象
被创建。这个类提供了访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
1. 单例类只能有一个实例
2. 单例类必须自己创建自己的唯一实例
3. 单例类必须给所有其他对象提供这一实例

### 单例模式的使用场景
1. 要求生产唯一序列号
2. WEB中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来
3. 创建一个对象需要消耗的资源过多，比如I/O与数据库的连接

### 单例模式的实现（要会写）
1. 懒汉式（线程安全/线程不安全）
2. 饿汉式
3. 双重校验（DCL，double-checked locking）

### 单例模式的优点
1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）
2. 避免对资源的多重占用（比如写文件操作）

### 单例模式的缺点
没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

## 4建造者模式

## 5原型模式（有问到过）


